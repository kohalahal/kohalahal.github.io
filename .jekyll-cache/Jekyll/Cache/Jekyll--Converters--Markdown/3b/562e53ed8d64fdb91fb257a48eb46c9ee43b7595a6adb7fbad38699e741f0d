I"P*<p>※<i>이탤릭 체는 자바정석으로 공부한 나의 재구성+따로 찾은 내용</i></p>
<h2 id="제2장-변수h2">제2장 변수&lt;/h2&gt;</h2>

<h3 id="기본형-변수h4">기본형 변수&lt;/h4&gt;</h3>

<table rules="groups">
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">4</th>
      <th style="text-align: right">8</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">논리</td>
      <td style="text-align: center">불린</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: right"> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td style="text-align: left">문자</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">찰</td>
      <td style="text-align: center"> </td>
      <td style="text-align: right"> </td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td style="text-align: left">정수</td>
      <td style="text-align: center">바이트</td>
      <td style="text-align: center">쇼트</td>
      <td style="text-align: center">인트</td>
      <td style="text-align: right">롱</td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td style="text-align: left">실수</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">플롯</td>
      <td style="text-align: right">더블</td>
    </tr>
  </tbody>
</table>
<table>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>4</th>
<th>8</th>
</tr>
<tr>
<th>논리</th>
<td>불린</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th>문자</th>
<td></td>
<td>찰</td>
<td></td>
<td></td>
</tr>
<tr>
<th>정수</th>
<td>바이트</td>
<td>쇼트</td>
<td><b>인트</b></td>
<td>롱</td>
</tr>
<tr>
<th>실수</th>
<td></td>
<td></td>
<td>플롯</td>
<td><b>더블</b></td>
</tr>
</table>

<p>찰의 내부는 유니코드 정수라서 정수 타입이라고도 할 수 있다.</p>

<p>실수형은 정수형과 저장방식이 달라서(IEEE754) 같은 용량에도 더 큰 범위를 저장할 수 있다.</p>

<p>하지만 오차가 발생할 수 있다.</p>

<p>정수형에서 int가 CPU효율적.</p>

<h3>애들의 범위</h3>

<p>바이트: -2의7승~2의7승-1 = -128~127</p>

<p>int: -2,147,…~2,147,… 10자리 숫자(운세보기에서 이름 생일 오늘날짜 막곱하다보니 int범위 넘어갔는지 음수가 나왔다.)</p>

<p>롱: -9,223,…~9,223,… 19자리 숫자</p>

<p>플롯: 1.4<em>10의-45승~3.4</em>10의38승 = 0.000,…..014 소수점 46자리~34….39자리 숫자?인데 정밀도는 7자리</p>

<p>더블: 4.9<em>10의-324승~1.8</em>10의308승인데 정밀도는 15자리</p>

<p>인트(10자리까지)-&gt;플롯(정밀도가 7자리) 형변환하면 오차생길수있다.</p>

<p>인트-&gt;롱이 안전하다.</p>

<h3>오버플로우</h3>

<p>타입이 표현할수있는 값 범위 넘어서는것. 에러는 아니지만 정확한 값이 안나온다.</p>

<p>정수: 최대값+1은 최소갑, vice versa</p>

<p>실수: 최대값+a는 무한대, 최소값-a는 0</p>

<h3>제3장 연산자</h3>

<p>※타입의 최대값 주의</p>

<p>ex) long a = 1,000,000 * 1,000,000;하면</p>

<p>int*int라서 오버플로우 발생, a는 음수로 잘못 나온다.</p>

<p>※char 유니코드</p>

<p>‘0’~’9’ : 48~57</p>

<p>‘A’~’Z’ : 65~90</p>

<p>‘a’~’z’ : 97~122</p>

<p>char a = 35;라고 정수 넣어두면 그 값의 문자가 나온다.</p>

<p>char b = ‘3’;이라고 문자를 넣을 수도 있다.</p>

<p>※논리 연산자는 왼쪽부터 연산한다. 답이 나왔으면 다음 것 안본다.</p>

<p>효율을 생각해서 순서 배치하자.</p>

<h3>제5장 배열</h3>

<p>Arrays 클래스는 배열의 편의메소드들이 담긴 Collections 프레임워크의 멤버 클래스. 인스턴스화는 불가.</p>

<p>※배열의 복사는 System.arraycopy()가 효율적.</p>

<h3>제6장 객체지향 1</h3>

<p>객체지향 프로그래밍의 특징</p>

<ol>
<li>코드 재사용성</li>
<li>코드 관리 용이</li>
<li>신뢰성 높은 프로그래밍-데이터 보호, 올바른 값 유지</li>
</ol>

<p><i>내 정리(틀릴 수도 있음):</i></p>

<p>c언어를 보면 main이 액션을 할 수 있는 최소 단위였다.</p>

<p>데이터, 명령들을 단위로 묶어두기는 했지만, 그게 다였다.</p>

<p>main에다가 써야지 실행이 됐다. 하나의 execute은 하나의 main만 실행한다. main이 액션의 최대 단위이기도 한 것.</p>

<p>oop에서는 main이 데이터, 함수 묶음 속으로 들어가고, 그 묶음이 액션 할 수 있는 최소 단위가 됐다.</p>

<p>그것을 객체라 부른다.</p>

<p>그리고 그 바깥에는 이제 main이 아예 존재하지 않게됐다.</p>

<p>객체도 액션의 최소이면서 최대 단위인 것.</p>

<p>그래서 어디 나오는 자판기 예시처럼, 각 객체가 자기 일을 알아서 할 수 있게 됐다.</p>

<p>코드 재사용성은 절차적 언어에도  없는 건 아니지만 암튼 더~마니 묶으니(데이터들+함수들) 더 재사용이 용이할 것이다.</p>

<p>다른데다가 가져가서 쓰기도 편하다.</p>

<p>그리고 객체 하나만 있어도 동작할 수 있으니 테스트하기도 편하고, 적절하게 나누면 수정하기도 편하다.</p>

<p>그리고 각 객체가 자기 데이터를 갖고있어서, 값을 가릴수도 있고 안줄 수도 있어서 데이터 보호, 올바른 값 유지에 좋다.&lt;/i&gt;</p>

<p>클래스:</p>

<ol>
<li>객체 정의해놓은 것 -&gt; 객체 생성에 사용한다.</li>
<li>데이터의 집합(타입 상관 없다.)+함수들</li>
<li>사용자 정의 타입</li>
</ol>
<p>멤버: 변수와 메소드</p>

<p><i>인스턴스: 클래스 실행한 것.</i></p>

<p>참조변수: 인스턴스에 붙이는 이름. 이름 안붙여주면 다시 부를 수 없다.&lt;/i&gt;</p>

<p>변수:</p>

<p>클래스 변수 - 모든 인스턴스가 공유. 인스턴스 없어도 사용 가능. <i>희미한 main의 흔적?? 기본형 타입과 함께</i></p>

<p>인스턴스 변수 - 각 인스턴스는 자기 인스턴스 변수 가짐.</p>

<p>지역 변수 - 메서드 내</p>

<p>생성자: 인스턴스를 초기화하는 메소드</p>

<p>클래스 이름과 같다.</p>

<p>리턴 값이 없다.</p>

<p>※<i>인스턴스의 생성은 new 연산자가 한다. 저장공간 할당 바당 참조값을 객체에게 반환.</i></p>

<p>new가 런타임에 메모리를 받아서, 그 메모리의 참조를 클래스에 할당함으로 객체의 실제 물리적 카피 생성.</p>

<p>그 다음에 호출된 생성자가 새 객체를 초기화.</p>

<p>&lt;/i&gt;</p>

<h3>제7장 객체지향 2</h3>

<p>상속</p>

<p>생성자와 초기화 블럭은 상속되지 않는다.</p>

<p>멤버만 상속된다.</p>

<p>※<i>static 멤버도 다 상속은 된다.</i></p>

<p>근데 상속된다기 보다 부모 클래스의 static이 자식을 통해서도 참조가 되는 것 같다. 상속해서 똑같이 가지는 것은 아닌 듯.</p>

<p>만약에 static 멤버의 이름을 똑같이해서 오버라이딩하려고하면… 오버라이딩은 안된다. static에는 오버라이딩이 없다.</p>

<p>하지만 부모의 static을 가리게(hide) 된다.&lt;/i&gt;</p>

<p>오버라이딩시, 조상보다 더 많은 or 큰 예외를 던질 수는 없다.</p>

<p><i>예)자식 클래스가 부모 변수로 참조돼서, 부모도 가진 함수를 호출했는데, 더 예외를 많이 던지면 안되겠죠?</i></p>

<p>※<i>근데 생성자는 부모보다 접근자 좁아질 수 있다.</i></p>

<p>만들어진 자식클래스는 부모클래스랑 똑같은 역할을 다 할 수 있어야되는데, 그냥 생성부터 안되는건 괜찮은가봄&lt;/i&gt;</p>

<p>※<i>싱글턴하려면 상속 쓰는건 좀 아닌 것 같다.</i></p>

<h3>제8장 예외처리</h3>

<p>에러: 심각</p>

<p>예외: 다소 미약</p>

<p>에러의 종류: 컴파일 에러, 런타임 에러, 논리적 에러(의도와 다른 동작)</p>

<p>예외 처리-&gt; try-catch문:</p>

<p>catch(ArithmeticExceptionae){}문은 컴파일되면 안에 if(ae instanceof ArithmeticException){} 이게 생긴다.</p>

<p>예외가 발생하면 예외클래스 인스턴스가 만들어지고, 걔가 if에서 자기를 만나면 그 속에 들어 있는 캐치문이 실행되는 것이다.</p>

<p>예외 인스턴스(extends Exception) 만들어서 내가 throw 할 수 있다.</p>

<p>런타임 익셉션은 예외를 강제하지 않는 unchecked 예외이다. 다소 덜심각?!</p>

<p>다른 예외는 checked 예외.</p>

<p>※<i>근데 런타임 익셉션이 익셉션 자손이길래</i></p>

<p>try catch Exception으로 런타임 익셉션도 잡아지는가 해봤다. 잡아진다. 런타임 오류가 나서 실행은 안됐는데 아무 티가 안났다.</p>

<p>어쩌다 try catch속에 같이있어서 모르고 넘어가게되는 런타임 익셉션은 없을까?&lt;/i&gt;</p>

<p>※<i>Throwable도 클래스, Exception도 클래스…</i></p>

<p>예외들을 보면 클래스를 상속한 클래스를 상속한 클래스를 상속한 클래스를 상속한 클래스들로 이루어져있었다.</p>

<p>이펙티브 자바에서 이런거 하지말라고 한 게 생각났다.</p>

<p>계속 소스 보고 있는데 코드 저자 중에 조슈아 블록이 있었다.</p>

<p>이런걸 만들고 이펙티브 자바에서 상속하려면 하지말라고 했나보다.&lt;/i&gt;</p>

<h3>제9장 클래스 인스턴스?</h3>

<p>※<i>Object 클래스 메소드는 뭐 어케해놨는지 보려니까 native코드로 많이 돼 있었다.</i></p>

<p>clone같은거는 내가 더 잘 짤리 없으니 꼭 super.clone으로 어떻게 잘 해야겠다 생각했다.</p>

<p>getClass는 런타임 클래스이긴한데, 인스턴스는 아니고 런타임의 static 클래스?를 반환하는 것 같다.안확실함.</p>

<table>
  <tbody>
    <tr>
      <td>반환은 Class&lt;T extends</td>
      <td>X(호출된 자기)</td>
      <td>&gt;로 돼있다.</td>
    </tr>
  </tbody>
</table>

<p>equals는 그냥 ==으로 주소비교로 되어있었다.&lt;/i&gt;</p>

<p>equals 오버라이드하려면 hashcode도 오버라이드하라.</p>

<p>※<i>이클립스에서</i></p>

<p>String s = “”;</p>

<p>System.out.println(s == s.getClass());</p>

<p>해보려고 하면 아예 컴파일 오류가 난다. 이건 찾아보니까 그냥 이클립스가 못하는 것이라고 한다. 그럼 그냥 이클립스없이 해볼걸. 거기까진 안해봄.</p>

<p>&lt;/i&gt;</p>

:ET