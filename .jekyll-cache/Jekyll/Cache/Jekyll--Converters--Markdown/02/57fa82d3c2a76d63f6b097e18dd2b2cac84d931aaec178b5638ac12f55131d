I"n<p>제네릭은 자바 5부터 나왔는데 이전에는 컬렉션에서 객체 꺼낼 때 마다 형변환을 해야했다. 그래서 런타임 형변환 오류 나곤 했다. 반면 제네릭은 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게됨. 그래서 컴파일러가 알아서 형변환 코드 추가, 엉뚱타입 객체 넣으려는 시도를 컴파일 과정에서 차단.</p>

<h2 id="아이템26-로-타입은-사용하지-말라">아이템26 로 타입은 사용하지 말라</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>같이 클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 제네릭 클래스/제네릭 인터페이스임.</p>

<p>그런 걸 로 타입(실제 매개변수 타입 지정 안하고)으로 쓰지 말라. 제네릭의 이점인 안정성, 표현력 모두 잃는다.</p>

<p>컴파일에서 오류 발견 못하고 한참 뒤 런타임에 알아채게 된다.</p>

<p>타입 지정해서 타입 안정성 확보하라. 만약에 Object로 지정한다면, 그것은 컴파일러에게 모든 타입을 허용한다는 것을 정확히 전달한 것이라서 로 타입과 다르다.</p>

<p>원소 타입 몰라도 되는 걸 작성하고 싶으면 비한정적 와일드카드 타입unbounded wildcard type을 써라.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;?&gt;</span>
</code></pre></div></div>

<p>로타입과 달리 안전하다. 로 타입에는 아무 원소나 넣을 수 있지만 ?에는 null외에 어떤 타입도 넣을 수 없다.</p>

<dl>
  <dt>소소한 예외</dt>
  <dd>class 리터럴에는 로 타입 , instanceof연산자에는 로타입
~~~java
예)List.class -&gt; OK
List<String>.class -&gt; NG</String></dd>
</dl>

<p>if(o instanceof Set) {
    Set<?> s = (Set<?>) o;
}
~~~</p>

<h2 id="아이템27-비검사-경고-제거하라">아이템27 비검사 경고 제거하라</h2>

<h2 id="아이템28-배열보다-리스트">아이템28 배열보다 리스트</h2>

<h2 id="아이템29-이왕이면-제네릭-타입">아이템29 이왕이면 제네릭 타입</h2>

<h2 id="아이템30-이왕이면-제네릭-메서드">아이템30 이왕이면 제네릭 메서드</h2>

<h2 id="아이템31-한정적-와일드카드-사용해-api-유연성-높여라">아이템31 한정적 와일드카드 사용해 API 유연성 높여라</h2>

<h2 id="아이템32-제네릭과-가변인수-함께-쓸-때는-신중하라">아이템32 제네릭과 가변인수 함께 쓸 때는 신중하라</h2>

<h2 id="아이템33-타입-안전-이종-컨테이너를-고려하라">아이템33 타입 안전 이종 컨테이너를 고려하라</h2>

:ET