---
layout: post
title: RESTful api
categories : study
---

### 그놈의 RESTful api


rest api가 뭔지 모르겠고 어려웠는데 이제야 알았다.
그냥 서버가 유저(클라이언트) 신경안쓰고 일할 수 있도록 그 둘을 분리시켜준 것이다.

stateless '상태가 없다'는 것은 쉽게 말해 과거가 없다는 것이다.
'이 유저가 과거에 뭘 했었다' 이런 과거를 1.기록도 안하고, 2.참고도 안하는 것이다.

예전에는 가게(서버)에서 유저를 알아보고 거기맞춰 서비스를 했다면
이제는 손님이 너~~~무 많아지는 바람에 
유저가 자기가 받을 서비스에 필요한 정보를 전부 가게(서버)에 갖고가야 하는 것이다. 바로 또 다시 들릴때도 똑같은 준비물을 갖고 가야한다.
결국 가게 입장에서는 누구던지 처음오는 손님처럼 대하면 돼서 훨씬 편하게 일할 수 있게 된 것이다.

로그인은 그래서 더 복잡한 것 같다.
OAuth같은 경우에는 http에다 담아두니까 엄밀하게 stateless가 아니라고 하는 글도 있었다.


레스트풀의 6가지 조건
1. 클라이언트와 서버 분리
2. 무상태
3. 캐셔블(내지는 캐셔블인지 아닌지 응답에 표시)
4. 통일된 사용법(인터페이스-클라이언트가 사용하기 용이하게 주소나 메소드 잘 통일하라)
5. 다층 시스템(위계가 있고, 내 바로 위 아래층 시스템이랑만 동작하는 다층 시스템)
6. 코드 온 디맨드(선택적-클라이언트가 실행할 코드까지 서버가 다 주면 클라이언트 확장이 용이하고 또 클라이언트가 가벼워진다)
이러하다.
아직 다는 모르겠다.



REST가 뭘 말하는지 모르겠다가 이제야 좀 알겠는데 조금 허무했다.
그리고 rest"풀"이 꼭 최선은 아닌 것 같다.

HATEOAS는 rest"풀"을 위해 하는 것 같은데 restfulapi.net과 spring.io의 설명이 꽤나 달랐다.
하나는 하이퍼링크 주소치는거에 따라 동작하는 그런... 거라고 하고
하나는 링크들을 보냄으로서 상태를 함께 보내는 격이라고 했다.
후자가 더 적절한 것 같은데, 암튼 둘이 넘 달랐댜.
그리고 stateless가 되기위해서는 HATEOAS가 필요하겠지만 
클라이언트와 서버를 다 stateless를 만들더라도 결국 state를 만드는 정보를 안주고받는건 아닌 것 같다(?).
그래서 다른 이유가 더 없으면 안해도되는 거 같다.


